<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Magnum glTF Player</title>
  <link rel="stylesheet" href="WebApplication.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>
<body>
  <h1>Magnum glTF Player</h1>
  <div id="container">
    <div id="sizer"><div id="expander"><div id="listener">
      <canvas id="module" tabindex="0"></canvas>
      <div id="status">Initialization...</div>
      <div id="status-description"></div>
      <script src="EmscriptenApplication.js"></script>
      <script async="async" src="magnum-player.js"></script>
    </div></div></div>
  </div>
  <script>
    "use strict"; /* it summons the Cthulhu in a proper way, they say */

    /* Done here instead of using Sdl2Application::setContainerCssClass() so
       we can do extra things like hiding scrollbars on magnum.graphics. Not
       needed here though. */
    function setFullsize(fullsize) {
        if(fullsize) {
            document.getElementById('container').className = 'fullsize';
        } else {
            document.getElementById('container').className = '';
        }
    }

    Module.keyboardListeningElement = Module.canvas;
    Module.canvas.addEventListener('dragover', function(event) {
        event.stopPropagation();
        event.preventDefault();
        event.dataTransfer.dropEffect = 'copy';
    });
    Module.canvas.addEventListener('drop', function(event) {
        event.stopPropagation();
        event.preventDefault();

        const items = event.dataTransfer.items;
        if(!items) {
            console.error("No files dropped.");
            return;
        }

        /* Unrecurse the bag of dropped files and directories and then pass all
           files through to the player. Memory is allocated on the JS side and
           freed on the C++ side to avoid needless copies. The
           webkitGetAsEntry() is Chrome-specific and Firefox with Edge were
           forced to implement it, despite the name. Safari and IE don't know
           that, so we need to be careful. */
        var files = [];
        var traverseFiles = function(fileOrDirectory, path/*, files*/) {
            if(fileOrDirectory.isFile) {
//                 console.log(files);
                files.push([fileOrDirectory, path]);
            } else if(fileOrDirectory.isDirectory) {
                let dirReader = fileOrDirectory.createReader();
                let getE = function() {
                dirReader.readEntries(function(entries) {
                    for(let i = 0; i != entries.length; ++i) {
                        traverseFiles(entries[i], path + fileOrDirectory.name + "/"/*, files*/);
                    }
                });
                }

                getE();
            }
        };
        for(let i = 0; i != items.length; ++i) {
            /* TODO: this might get renamed to getAsEntry() in 2027 or so */
            if(typeof items[i].webkitGetAsEntry === "function") {
                traverseFiles(items[i].webkitGetAsEntry(), ""/*, files*/);
                continue;
            }

            /* If webkitGetAsEntry() is not supported or the dumpster is on
               fire some other way, simply push the file directly (it will fail
               later if directories are involved). This is duplicated below
               for the case of webkitGetAsEntry() supported -- it uses a
               different variable for total count and adds file path to the
               filename. */
            (function(file) {
                const fileReader = new FileReader();
                fileReader.onload = function(event) {
                    /* TODO: but still, isn't here way too much copying? */
                    const fileData = new Uint8Array(event.target.result);
                    const pointer = Module._malloc(fileData.length);
                    const data = new Uint8Array(Module.HEAPU8.buffer, pointer, fileData.length);
                    data.set(fileData);
                    Module.ccall('loadFile', null, ['number', 'string', 'number', 'number'], [items.length, file.name, pointer, fileData.length]);
                };
                fileReader.onerror = function() {
                    console.error("Unable to read file " + file.name);
                };
                fileReader.readAsArrayBuffer(file);
            })(items[i]); /* this is how you do a capturing lambda?! ugh */
        }
        console.log(files.length);
        for(let i = 0; i != files.length; ++i) {
            console.log("ugh", i);
        (function(file, path) {
            file.file(function(file) {
                const fileReader = new FileReader();
                fileReader.onload = function(event) {
                    /* TODO: but still, isn't here way too much copying? */
                    const fileData = new Uint8Array(event.target.result);
                    const pointer = Module._malloc(fileData.length);
                    const data = new Uint8Array(Module.HEAPU8.buffer, pointer, fileData.length);
                    data.set(fileData);
                    Module.ccall('loadFile', null, ['number', 'string', 'number', 'number'], [files.length, path + file.name, pointer, fileData.length]);
                };
                fileReader.onerror = function() {
                    console.error("Unable to read file " + file.name);
                };
                fileReader.readAsArrayBuffer(file);
            });
        })(files[i][0], files[i][1]); /* insane?! is this needed? */
        }
    });
    Module.canvas.addEventListener('mousedown', function(event) {
        event.target.focus();
    });
  </script>
</body>
</html>
